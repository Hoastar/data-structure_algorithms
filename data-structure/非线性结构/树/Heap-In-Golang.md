# 
## 引入
在实际应用中，我们经常需要从一组对象中查找最大值或最小值。当然我们可以每次都先排序，然后再进行查找，但是这种做法效率很低。但有种特殊的数据结构，可以高效的实现这种需求，那就是堆（heap）。

## 最小堆
### 实例
### 特性

* 一颗完全二叉树
> 如果一颗二叉树的任何结点，或者是树叶，或者是左右子树均非空，则这颗二叉树称作满二叉树（full binary tree）。

> 但也可这样理解：除最后一层无任何子 节点 外，每一层上的所有结点都有两个子结点（最后一层上的无子结点的结点为 叶子结点 ）。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值。所有叶子结点必须在同一层上

> 如果一颗二叉树最多只有最下面的两层结点度数可以小于2，并且最下面一层的结点都集中在该层最左边的连续位置上，则此二叉树称做完全二叉树（complete binary tree） (结点所拥有的子树的个数称为该结点的度(Degree))

* 局部有序
> 最小堆对应的完全二叉树中所有结点的值均不大于其左右子结点的值，且一个结点与其兄第结点之间没有必然的联系

> 二叉搜索树中，左子 < 父 < 右子

### 存储解构
由于堆是一颗完全二叉树，所以我们可用线性结构来存储它，只需要计算简单的代数表达式，就想当方便查找某个结点的父结点和子节点，既避免了使用指针来保持结构，又能高效的执行相应的操作。


结点i的左子结点为 2×i+1,右子结点为2×i+2 （i为结点的所在的索引值）
结点i的父节点为(i-1)/2


### 数据结构

```golang
// 采用最小堆
// 
type Heap []int

// swap 结点交换
func (h Heap) swap(i, j int) {
    h[i], h[j] = h[j], h[i]
}

// less 结点比较
func (h Heap) less(i, j int) bool {
    return h[i] <  h[j]
}
```

#### 插入操作

首先，先将新加入的元素加入末尾。为了保持最小堆的性质，需要沿着其祖先的路径，自下而上依次比较和交换该接点与父结点的位置，直到重新满足堆的性质。

如图所示

![](https://img2018.cnblogs.com/blog/1459179/201911/1459179-20191128102922596-781849710.png)

上浮情况如下：
* 新结点上升到最小堆的顶端
* 上浮到某一位置时发现父结点比新插入的结点关键值小。

```golang

// up 上浮操作
func (h Heap) up(i int) {
    for {
        // f 为父结点
        f := (i-1) / 2
        if i == f || h.less(f, i) {
            break
        }

        h.swap(f, i)
        i = f
    }
}


func (h *Heap) Push(x int) {
    *h = append(*h ,x)
    h.up(len(*h) - 1)
}
```

### 删除操作
首先把最末端的结果填入要删除结点的位置，然后删除末端元素，然而这样也会导致破坏最小堆的堆序特性。

为了保持堆的特性，末端元素需要与被删除的位置的父结点做比较，如果小于父结点，就要up操作；如果大于父结点，就要再和被删除位置的子结点做比较，即Down,直到该结点下沉到小于最小子结点的为止。

如图所示：

![](https://img2018.cnblogs.com/blog/1459179/201911/1459179-20191128101641309-1508208201.png) 

```golang
// down 下沉操作
func (h Heap) down(i int) {
    for {
        l := 2 * i + 1
        if l >= len(h) {
            // i 已经是叶子结点了
            break 
        }

        j := l

        // 如果右子结点小于左子结点
        if r := l + 1; r < len(h) && h.less(r, l) {
            // 将右子结点与左子结点中最小值赋给j
            j = r
        }
        
        // 比较i处结点与i的的最小子树
        if h.less(i, j) {
            break
        }

        // 交换父结点和子结点
        h.swap(i, j)
        
        // 继续向下比较
        i = j
    }
}
```

实现了核心的 down操作，remove就很简单了

```golang
func (h *Heap) Remove(i int) (int, bool) {
    if i < 0 || i > len(*h) - 1 {
        return 0, false
    }

    l := len(*h) - 1
    // 用最后的元素替换被删除元素
    h.swap(i, l)

    // 删除最后的元素
    x := (*h)[n]
    *h = (*h)[0:n]

    // 如果当前元素大于父结点
    if (*h)[i] > (*h)[(i-1)/2] {
        // 下沉
        h.down(i)
    } else {
        // 上浮
        h.up(i)
    }

    return x, true
}
```

### 弹出操作

其时，当i=0时，remove就是 Pop
```golang
// Pop弹出堆顶的元素，并返回其值
func (h *Heap) Pop() int {
    n := len(*h) - 1
    h.swap(0, n) 
    x := (*h)[n]
    *h = (*h)[0:n]
    h.down(0)
    return x
}
```

### 初始化
那我们该如何根据一个数组构造一个最小堆呢？

其时，我们可以将所有关键码放到一维数组中，此时形成的完全二叉树并不具备最小堆的特征，但是仅包含叶子结点的子树已经是堆。

```golang
func (h Heap) Init() {
    n := len(h)
    // 
    for i := n/2 - 1; i >= 0; i-- {
        h.down(i)
    }
}
```