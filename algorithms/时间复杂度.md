# 时间复杂度
## 概念
时间复杂度是一个函数，它定性描述该算法的运行时间。
到底该如何估计算法运行时间呢，通常会估算算法的操作单元数量来表达程序消耗的时间，这里默认cpu的每个单位运行消耗的时间是相同的。
假设算法的问题规模为n，那么操作单元数量便用函数f(n)表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称为算法的渐进时间复杂度，简称时间复杂度，记为O(f(n))

## 大O表示法
这里的大O是指什么呢，一谈起时间复杂度，大家都知道O(n), O(n^2)。
算法导论给出的解释是：大O用来表示上界的，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。
面试中说到算法的时间复杂度是多少都是一般情况。

不同算法的时间复杂度在不同数据输入规模下的差异。
在决定使用那些算法的时候，不是时间复杂度越低越好（因为简化后的时间复杂度忽略了常数项等）。要考虑数据规模，如果数据规模很小甚至可以用O(n^2)的算法比O(n)的更合适（在有常数项的时候）。

那为什么在计算时间复杂度的时候要忽略常数项系数呢，也就说O(100n) 就是O(n)的时间复杂度，O(5n^2) 就是O(n^2)的时间复杂度，而且要默认O(n) 优于O(n^2) 呢 ？

这里就又涉及到大O的定义，因为大O就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量。

所以我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示：

O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)(立方阶) < O(2^n) (指数阶)

但是也要注意大常数，如果这个常数非常大，例如10^7 ，10^9 ，那么常数就是不得不考虑的因素了。

## O(logn)中的log是以什么为底？
平时说的这个算法的时间复杂度是logN，那么到底是log以2为底的对数嘛？
其实也可以是以10为底，也可以是以20为底n的对数，但我们统一说 logn，也就是忽略底数的描述。

假如有两个算法的时间复杂度，分别是log以2为底n的对数和log以10为底n的对数，那么这里如果还记得高中数学的话，应该不难理解以2为底n的对数 = 以2为底10的对数 * 以10为底n的对数。

而以2为底10的对数是一个常数，在上文已经讲述了我们计算时间复杂度是忽略常数项系数的。

抽象一下就是在时间复杂度的计算过程中，log以i为底n的对数等于log 以j为底n的对数，所以忽略了i，直接说是logn。