# KMP算法

## 什么是KMP
说到KMP，为什么叫KMP？
因为这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP

## KMP有什么用
KMP算法主要用在字符串匹配上。
KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免在去从头匹配了。

所以如何记录已经匹配的文本内容，是KMP算法的重点，也是Next数组肩负的重任。

## 什么是前缀表
写过KMP的同学，一定都写过next数组，那么这个next数组究竟是个啥呢？

next数组就是一个前缀表（prefix table）。
前缀表有什么作用呢？
前缀表是用来回退的,它记录了模式串与主串（文本串）不匹配的时候，模式串应该从哪里重新开始匹配。

示例：
要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。

可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，会发现不匹配，此时就要从头匹配了。
但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。

此时就要问了，前缀表是如何记录的呢？
要明确一点的是，前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配。所以意味者在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。

## 前后缀
前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。

后缀是指不包括第一个字符串所有以最后一个字符结尾的连续子串。

正确理解什么是前缀、什么是后缀很重要！
因为前缀表要求的就是相同前后缀的长度。

而最长公共前后缀里面的“公共”，更像是说前缀和后缀的公共长度。这其实不是前缀表所表达的。

## 为什么要用前缀表
模式串"aabaaf" 与 文本串"aabaabaaf"匹配时，前者到下标为5的地方出现不匹配。模式串指向f，
接着就找到了下标2，指向b，继续匹配。

下标5之前的这部分字符串（也就是字符串"aabaa"）的最长（此时匹配最优）相等的前缀和后缀字符串是 字符串"aa"，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的下一位，那么我们找到与其相同的前缀的下一位（后面）重新匹配就好了。

## 如何计算前缀表
"aabaaf"的子串最长前后缀分别为：
```
子串"a"：不存在这样的前缀、后缀，最长前后缀长度为0
子串"aa"：
    前缀：a
    后缀：a
    最长相同前后缀为"a"，长度为1
子串"aab"：
    前缀：a, aa
    后缀：b, ab
    a != b, aa != ab
    无最长相同前后缀，长度为0
子串"aaba"：
    前缀：a, aa, aab
    后缀：a, ba, aba
    a == a, aa != ba, aab != aba
    存在最长相同前后缀"a"，长度为1

子串"aabaa"：
    前缀：a, aa, aab, aaba
    后缀：a, aa, baa, abaa
    a == a, aa = aa, aab != baa, aaba != abaa
    存在相同前后缀，分别是 "a"， "aa"，那么最长为串"aa"，长度为2

子串"aabaaf"：
    前缀：a, aa, aab, aaba, aabaa
    后缀：f, af, aaf, baaf, abaaf 
    所有的前后缀都不相等，所以不存在相同前后缀，长度为0
```

那么模式串"aabaaf"前缀表也就是Next数组的值为：[0,1,0,1,2,0]

可以看出模式串与前缀表对应位置的数字表示的就是：下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。

当模式串"aabaaf"与文本串"aabaabaaf"进行匹配时，发现文本串位置i=5，模式串位置j=5时，出现不匹配。此时我们得看它的前一个字符所在子串对应的前缀表的数值是多少。

为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。

所以要看前一位的 前缀表的数值。

那么Next[j-1] == 2，那么把模式串的下标j移动到2的位置，继续跟文本串匹配。

## 前缀表与数组
看了许多KMP算法的实现都是使用Next数组来回退操作，那么Next数组与前缀表有什么关系呢？

next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。

## 使用Next数组来匹配
我们使用常规的本来的Next数组来匹配文本串与模式串即可。

## 时间复杂度分析
其中n为文本串长度，m为模式串长度，在匹配的过程中，根据前缀表不断调整匹配的位置，可看出匹配过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。

通常暴力解法是O(n*m)，KMP算法效率还是相当高的。

## 构造Next数组
定义getNext函数来构造数组，函数参数为指向Next数组的指针和一个字符串。如下：
```go
func getNext(&[]int, str string) {}
```

构造Next数组就是计算模式串str的前缀表的过程。分三步：
1. 初始化
2. 处理前后缀不相同的情况
3. 处理前后缀相同的情况

* 初始化
    * 定义俩个指针j和i，j指向前缀起始的位置，i指向后缀起始的位置。然后还要对Next数组进行初始化赋值，如下：
        ```go
        j := 0
        next[0] = j
        ``` 
        拿子串子串"a"来说：
        ```
        子串"a"：不存在这样的前缀、后缀，最长前后缀长度为0
        ```
        Next[i]表示i（包括i）之前最长相等的前后缀长度就是j。初始化Next[0] = j
* 处理前后缀不相同的情况：
    j初始化为0，i就从1开始，进行s[j] 与 s[i]的比较。
    所以遍历模式串s的循环下标i要从1开始，代码如下：
    ```go
    for i := 1; i < len(s); i++ {}
    ```
    如果s[i]与s[j]不相同，也就是遇到前后缀末尾不相同的情况，就要像前回退。

    如何回退呢？
    Next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。

    那么 s[i] 与 s[j] 不相同，就要找 j前一个元素在next数组里的值（就是next[j-1]）。
    ```go
    for j > 0 && s[i] != s[j] {
			j = next[j-1] // 回退前一位
		}
    ```
* 处理前后缀相同的情况：
    如果s[i]与s[j]相同，那么就同时向后移动i和j，说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给Next[i]，因为Next[i]要记录着相同前后缀的长度。
    ```go
        if s[i] == s[j] {
            j++
        }
        Next[i] = j
    ```

整体构建代码如下：
```go
func getNext(next &[]int, str string) {
    j := 0
    next[0] = j
    for i := 1; i < len(s); i++ {
        for j > 0 && s[i] != s[j] {
			j = next[j-1] // 回退前一位
		}

        if s[i] == s[j] {
            j++
        }
        Next[i] = j
    }
}
```

## 使用Next数组来做匹配
在文本串s里 找是否出现过模式串t。

定义两个下标，j指向模式串起始位置，i指向文本串起始位置。

j的初始位置依然为0，依然因为Next数组里记录的起始位置为0。
i从0开始，遍历文本串：
```go
    for i := 0; i < len(s); i++
```
接下来，s[i]与t[j]进行比较。
如果s[i]与t[j]不同，j就要从数组里寻找下一匹配的位置。

代码如下：
```go
    for j > 0 && s[i] ！= s[j] {
        j = next[j-1] 
    }
```

如果s[i]与s[j]相同，那么i 和 j 同时向后移动， 代码如下：
```go
    if s[i] == s[j] {
        j++ // i的自增在循环里
    }
```

如何判断文本串s里出现了模式串呢，如果j从0开始，那么j指向模式串的长度，那么就说明模式串t完全匹配文本串s里的某个子串了。

本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去模式串的长度，就是文本串字符串中出现模式串的第一个位置。

代码如下：
```go
if j == len(t) {
    return (i - len(t) + 1)
}
```

那么使用Next数组，用模式串匹配文本串整体的代码如下：

```go
j := 0
for i := 0; i < len(s); i++ {
    // s 文本串， i为起始位置
    // t 模式串， j为起始位置
    for j > 0 && s[i] != t[j] {
        j := next[j-1]
    }

    if s[i] == t[j] {
        j++
    }

    if j == len(t) {
        return (i - len(t) + 1)
    }
}
```

具体代码如下：
```go
func strStr(haystack string, needle string) int {
	pL := len(needle)
	if pL == 0 {
		return 0
	}
	// 定义下标i,j
	// j为模式串起始位置
	// i为文本串起始位置
	j := 0
	next := make([]int, pL)
	getNext(next, needle)
	for i := 0; i < len(haystack); i++ {
		for j > 0 && haystack[i] != needle[j] {
			j = next[j-1]
		}

		if haystack[i] == needle[j] {
			j++
		}

		if j == pL {
			return i - pL + 1
		}
	}
	return -1
}

func getNext(next []int, str string) {
	// 定义俩指针，初始化
	j := 0
	next[0] = j
	for i := 1; i < len(str); i++ {
		// 循环判断前后缀不相等
		for j > 0 && str[j] != str[i] {
			j = next[j-1]
		}

		// 判断前后缀相等
		if str[j] == str[i] {
			j++
		}
        // 将j（前缀的长度）赋给next[i]
		next[i] = j
	}
}
```